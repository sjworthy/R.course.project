#To get single traits into a square matrix for mpd/mntd functions

obs.mpd.funk=function(tdm, column, cdm, null){
trait.p=as.matrix(tdm[,column])
rownames(trait.p)=rownames(tdm)
dist.trait.p=dist(trait.p, method="euclidean")
sq.dist.p=as.matrix(dist.trait.p)
obs.mpd=mpd(cdm, sq.dist.p, abundance.weighted=F)
ses.all=(obs.mpd-apply(null, MARGIN=1, mean))-apply(null, MARGIN=1, sd)
p.vall.all=apply(cbind(obs.mpd, null), MARGIN=1, rank)[1,]/1000
return(list(obs.mpd, ses.all, p.vall.all))
}

obs.mpd.p=obs.mpd.funk(q2.tdm, 4, q2.cdm, q2.pull.p)




#To determine ses values for one community at a time
ses.1=(obs.mpd.p-rowMeans(q1.mpd.p.rand[1,]))/sd(q1.mpd.p.rand[1,])

#Determine the rank 
q1.mpd.pull=as.pumeric(q1.mpd.p.rand)
rank.1=rank(c(height.obs, q1.mpd.p.rand[1,]))[1]

#determine p.val is equal to the rank divided by the number of null model iterations plus 1
p.val=rank.1/11

#For all communities at the same time
ses.all=(obs.mpd.p-apply(q1.pull.p, MARGIN=1, mean))-apply(q1.pull.p, MARGIN=1, sd)

p.val.all=apply(cbind(obs.mpd.p, q1.pull.p), MARGIN=1, rank)[1,]/1000

obs.mpd.p=obs.mpd.funk(q5.tdm, 6, q5.cdm, q5.p.null)

q5.p.ses.output=matrix(data=NA, ncol=4, nrow=16)
colnames(q5.p.ses.output)=c("mpd.obs", "mpd.obs.rank", "mpd.obs.z", "mpd.obs.p")
rownames(q5.p.ses.output)=c(250, 300, 350, 400, 450, 500, 550, 600, 650, 700, 750, 800, 850, 900, 950, 1000)

q5.p.ses.output[,3]=obs.mpd.p[[2]]
q5.p.ses.output[,4]=obs.mpd.p[[3]]
q5.p.ses.output[,1]=obs.mpd.p[[1]]
q5.p.ses.output[,2]=obs.mpd.p[[3]]*1000

write.csv(q5.p.ses.output, file="q5.p.ses.output.csv")